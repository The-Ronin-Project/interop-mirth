# Values used for Mirth, variables values should be either defined here or in .env
QUEUE_DB_URL=jdbc:mysql://mockehrmysql:3306/interop-queue
QUEUE_DB_USERNAME=$QUEUE_DB_USERNAME
QUEUE_DB_PASSWORD=$QUEUE_DB_PASSWORD

AIDBOX_CLIENT_ID=$AIDBOX_CLIENT_ID
AIDBOX_CLIENT_SECRET=$AIDBOX_CLIENT_SECRET
AIDBOX_REST_URL=http://devbox:$AIDBOX_PORT
AIDBOX_URL=http://devbox:$AIDBOX_PORT
TENANT_DB_URL=jdbc:mysql://mockehrmysql:3306/interop-ehr
TENANT_DB_USERNAME=$EHR_DB_USERNAME
TENANT_DB_PASSWORD=$EHR_DB_PASSWORD

DATABASE=postgres
DATABASE_NAME=mirthdb
DATABASE_USERNAME=mirthdb
DATABASE_PASSWORD=mirthdb

DATABASE_URL=jdbc:postgresql://mirth-db:5433/$DATABASE_NAME
DATABASE_MAX_CONNECTIONS=20
DATABASE_MAX_RETRY=2
DATABASE_RETRY_WAIT=10000
KEYSTORE_STOREPASS=docker_storepass
KEYSTORE_KEYPASS=docker_keypass
POSTGRES_USER=$DATABASE_USERNAME
POSTGRES_PASSWORD=$DATABASE_PASSWORD
POSTGRES_DB=$DATABASE_NAME

EHRDA_URL=http://ehr-data-authority:8080
EHRDA_AUTH_TOKEN_URL=http://mock-oauth2:8080/ehr/token
EHRDA_AUTH_AUDIENCE=https://ehr.dev.projectronin.io
EHRDA_AUTH_CLIENT_ID=id
EHRDA_AUTH_CLIENT_SECRET=secret
EHRDA_AUTH_AUTH0=false

VMOPTIONS=-Xmx512m

OCI_TENANCY_OCID=$OCI_TENANCY_OCID
OCI_USER_OCID=$OCI_USER_OCID
OCI_FINGERPRINT=$OCI_FINGERPRINT
OCI_PRIVATE_KEY_BASE64=$OCI_PRIVATE_KEY_BASE64
OCI_NAMESPACE=$OCI_NAMESPACE
OCI_CONCEPTMAP_BUCKET_NAME=$OCI_CONCEPTMAP_BUCKET_NAME
OCI_PUBLISH_BUCKET_NAME=$OCI_PUBLISH_BUCKET_NAME
OCI_REGION=$OCI_REGION

KAFKA_CLOUD_VENDOR=$KAFKA_CLOUD_VENDOR
KAFKA_CLOUD_REGION=$KAFKA_CLOUD_REGION
KAFKA_BOOTSTRAP_SERVERS=$KAFKA_BOOTSTRAP_SERVERS
KAFKA_PUBLISH_SOURCE=$KAFKA_PUBLISH_SOURCE
KAFKA_RETRIEVE_GROUPID=$KAFKA_RETRIEVE_GROUPID
KAFKA_PROPERTIES_SECURITY_PROTOCOL=$KAFKA_PROPERTIES_SECURITY_PROTOCOL
KAFKA_PROPERTIES_SASL_JAAS_CONFIG=$KAFKA_PROPERTIES_SASL_JAAS_CONFIG
KAFKA_PROPERTIES_SASL_MECHANISM=$KAFKA_PROPERTIES_SASL_MECHANISM

# Should this be running? Probably. But none of the current tests cause Validation errors, and getting an auth token is incredibly hard
# The approach we use in the validation IT tests does not work in this case because we're relying on the Auth0 service, which uses a proprietary method
# We would need to create our own auth server capable of serving up valid Auth tokens and providing the keys through the /.well-known/ standards.
VALIDATION_SERVER_URL=http://no-validation-server-is-running:8080/
VALIDATION_AUTH_TOKEN_URL=http://no-validation-auth-server:8080/token
VALIDATION_AUTH_AUDIENCE=https://interop-validation.dev.projectronin.io
VALIDATION_AUTH_CLIENT_ID=clientId
VALIDATION_AUTH_CLIENT_SECRET=secret

VAULT_URL=$VAULT_URL
VAULT_ROLE_ID=interops_role
VAULT_SECRET_ID=interops_secret
ENVIRONMENT=dev
